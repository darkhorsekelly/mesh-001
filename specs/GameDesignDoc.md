# MESH

2026 Prototype Game Design Document

_Version 1.0: A vertical slice of the minimal version of every system_

## Philosophy

Objective: Deploy the smallest complete version. It's fully playable with every system in its absolute most reduced form.

Core Principle: Build a complete game loop. Not impressive features. Every system interconnects. Every system is minimal.

Design Principle: Everything Euclidean.

* Every emergent property of the game is rooted in math
  * This is the secret sauce that allows infinite and unsupervised emergence
* New game content is defined mathematically, producing a flexibly-deterministic game
  * New game content is generated by heavily-moderated genAI technologies that provide novel player actions and respond to those actions with novel mechanics through mathematical expressions that fit the mechanism
* So every minisystem must support a deterministic outcome for any mathematical input: creating infinite emergence
  * genAI technologies are then capable of building new composite systems in every direction, creating a literal universe of experiences and content

Technical Principle: Functionally-defined Objects / Emergent Object Models / Functional Object Programming

## A game in three layers

Players exist as an abstraction across three interconnected layers (or “zooms”). The game does not force you into one. You choose where to spend your time and how much exposure and investment you have on each layer.

| Layer | What it is | What you control |
| :------ | :----------- | :----------------- |
| **Bodies** | Your physical presence(s) in the world | Location, exploration, "dungeon delving", moral choices, direct action, upgrades, inventory |
| **Holdings** | What you control, what you own | Zones, stockpiles, contracts, installations |
| **Network** | Who knows you | Alliances, debts, reputation, and intelligence |

## A game with 12 miniature systems

### 1. Galaxy

The universe in its smallest form.

#### Galaxy: minimal definition

* One-star system (Sol)
* Two planets orbit it
* Hardcoded, not generated
* Named: Terra, Luna

#### Galaxy: Future expansion

Multiple star systems. Procedural generation. Discovery mechanics. Hidden systems.

### 2. Planet topology

The game board. This is the only real visual in the game. It must be right.

#### Planet: Minimal definition

* ~7 Voronoi zones per planet, generated from random seed points
* Each zone has: terrain type (from 4 options), hidden strength (1–5), owner (player/unclaimed)
* Rendered as a flat 2D colored SVG mesh
* No heightmap yet. Just the tessellation with color-coded ownership

Terra:

* Rocky/volcanic, Mars-like. Regolith, basins, lava tubes, scarps.

Luna:

* Icy, Europa-like. Chaos terrain, pressure ridges, cryovolcanic fields, and sublimation pits.

#### Planet: Terrain types

| Type | Analog | Gameplay |
| :--- | :----- | :------- |
| Regolith Basin | Lunar mare, Martian lowlands | Easy movement, exposed, average resources |
| Impact Ejecta | Crater surroundings | Difficult terrain, good cover, scattered minerals |
| Volcanic Deposit | Olympus Mons flanks, Io surface | Rich in metals, unstable (random events?) |
| Ice Field | Europa, polar caps | Water as a resource, fortification bonus (dig in) |

#### Planet: Future expansion

Heightmaps. Procedural biomes. Terrain effects on combat. Weather systems.

### 3. Player

You are a consciousness that controls bodies. You begin with one body.

#### Player: Minimal definition

* One body per player (to start)
* Body has: name, current zone, current planet, inventory (list of items), home planet
* No stats, no levels, no skill trees
* Progression is purely positional and material: what you own, where you are

#### Player: Future expansion

Multiple bodies (rare acquisition). Body specialization. Permadeath with consciousness transfer. Party mechanics.

### 4. Minerals

The fundamental resource. Everything costs minerals or converts to minerals.

#### Minerals: Minimal definition

| Mineral | Color | Notes |
| :------ | :---- | :---- |
| Alpha | Red | Common, used in basic contracts |
| Beta | Blue | Uncommon, required for equipment |
| Gamma | Green | Rare, high contract value |

* Zones contain 0–3 of a single mineral type
* Exploring a zone reveals and extracts minerals
* Minerals are portable. They travel with your body

#### Minerals: Future expansion

Composite minerals (crafted from combinations). Mineral deposits that regenerate. Emergent mineral types generated by AI within constraints. Emergent item crafting generated by AI within constraints.

### 5. Equipment

Tools that modify your capabilities. Simple, deterministic effects.

#### Equipment: Minimal definition

| Item | Effect | How Acquired |
| :--- | :----- | :----------- |
| Scanner | Reveals adjacent zone strength before committing | Found or bought |
| Shield | +1 defense when your zone is attacked | Found or bought |
| Drill | +1 mineral yield when exploring | Found or bought |

* No crafting in minimal version
* Equipment is portable. It travels with body
* One of each type maximum per body

#### Equipment: Future expansion

Crafting system. Equipment degradation. Emergent equipment types. Vehicles are a separate equipment category. More equipment categories. Equipment can be on-person or in a zone or on a planet generally, or exist as a vector in space, or exist as an object in space or spatially exist in infinite interplanetary ways, or exist in a broad area emitting from a point, or exist as two points with a connection between them. It's all Euclidean and math.  

## 6–11. Actions

Players submit actions during the day. All actions resolve simultaneously at midnight UTC. This is the Diplomacy heartbeat.

### 6. Exploration

The primary way to acquire resources and discover information.

#### Exploration: Minimal definition

* Action: "Explore Zone X" (must be in that zone)
* Resolution: Random outcome from weighted table

| Outcome | Probability | Result |
| :------ | :---------- | :----- |
| Find Minerals | 70% | Random type, random amount 1–3 (Drill adds +1) |
| Find Equipment | 20% | Random item from the three types |
| Hostile Encounter | 10% | Lose a turn, nothing else |

* One procedurally-assembled sentence describes what happened

#### Exploration: Future expansion

Multi-step encounters. Emergent encounter types. Zone-specific encounter tables. Risk/reward choices during exploration.

### 7. Movement

How bodies traverse the map.

#### Movement: Minimal definition

* Action: "Move to Zone X" (must be adjacent to current zone)
* Resolution: You are now there. No cost. No failure chance.
* Inter-planet travel: "Travel to Planet Y" (takes one full day, you're in transit)

#### Movement: Future expansion

Movement costs. Terrain effects on travel. Vehicles that extend range. Blockades.

### 8. Fortification

Building up your defensive position.

#### Fortification: Minimal definition

* Action: "Fortify Zone X" (must own it)
* Resolution: Zone strength +1, capped at 5
* Does not require body presence, can fortify remotely

#### Fortification: Future expansion

Fortification costs minerals. Defensive installations. Traps. Auto-defenses.

### 9. Incursion

The Stratego kernel. Blind commitment with hidden information.

#### Incursion: Minimal definition

* Action: "Incur Zone X" with committed force value (1–3)
* Target zone has hidden defense strength (1–5)
* Resolution: If attacker force > defender strength, attacker captures zone
* If attacker force ≤ defender strength, attack fails, nothing changes
* Scanner equipment reveals target strength before commitment

#### Incursion: Key tension

You don't know the defender's strength unless you've scouted. You commit blind. This is where the Stratego bluffing emerges.

#### Incursion: Future expansion

Force costs resources. Support orders from allies. Attacker casualties on failed incursions. Siege mechanics.

### 10. Contracts

The economic engine. External pressure from the megacorp.

#### Contracts: Minimal definition

* One megacorp exists: "The Combine"
* Combine posts 3 contracts per day, randomly generated
* Contract format: "Do X, receive Y, deadline Z days"
* Players can accept one contract per day
* Fulfillment checked at midnight tick

#### Contracts: Example contracts

| Contract | Reward | Deadline |
| :------- | :----- | :------- |
| Deliver 2 Alpha minerals | 1 random equipment | 3 days |
| Hold Zone 7 on Terra | 5 minerals (any type) | 5 days |
| Explore 3 zones on Luna | 3 Beta minerals | 2 days |

#### Future expansion

Player-to-player contracts. Bounties. Assassination contracts. Derivative instruments. Contract reputation.

### 11. Trade

Player-to-player exchange. The Diplomacy negotiation layer.

#### Trade: Minimal definition

* Action: Post "Offering X for Y" to public trade board
* Other players can accept (also an action)
* Resolution: Direct swap at midnight tick
* No negotiation. No escrow. No partial trades.

#### Trade: Key design choice

The game provides no chat system. Players must negotiate out-of-band (Discord, email, etc.). This makes trust real, not simulated.

#### Trade: Future expansion

Private trades. Escrow for high-value exchanges. Trade reputation. Market price history.

### 12. Daily resolution

The heartbeat of the game. All actions resolve simultaneously at midnight UTC.

#### Resolution order

1. Movement (all bodies arrive at new locations)
2. Exploration (outcomes determined, resources distributed)
3. Fortification (zone strengths updated)
4. Incursion (attacks resolved, ownership changes)
5. Contracts (fulfillment checked, rewards distributed)
6. Trade (swaps executed)

#### Resolution: Key property

Simultaneous resolution means no player has information advantage during the day. Everyone commits blind. Everyone discovers outcomes together.

### 13. Persistence

How the game remembers itself.

#### Persistence: Minimal definition

* Game state: Single JSON file containing all entities
* Action queue: Second JSON file containing pending actions
* Event log: Third JSON file containing historical outcomes
* Midnight cron job: Read state + queue → run resolver → write new state + events → clear queue

#### Persistence: Future expansion

Database persistence. Action replay for debugging. State snapshots for rollback. Distributed state for scale.

### 14. Presentation

The interface. Text and menus, with one critical visual.

#### Presentation: Minimal definition

* Planet map: SVG rendered from Voronoi zone data, color-coded by ownership
* Sidebar: Player state (location, inventory), available actions
* Action submission: Dropdown menus and buttons
* Event log: Text list of yesterday's outcomes
* No animations. No sound. No real-time updates.

#### Presentation: The map is everything

The planet topology is the only visual. It must be immediately legible: who owns what, where you are, what's adjacent. If the map fails, the game fails.

#### Presentation: Future expansion

Heightmap visualization. Procedural animations for resolution events. Mobile-responsive design (?). Notifications.

### 15. GenAI Integration

Flavor text generation. Use ollama locally until it matters to prove the generative-emergent concept.

#### GenAI: Minimal definition

* Feed it a lore book: fragments describing the world, like an indie TTRPG zine
* Structured outputs: Need to prove the generative-emergent model and actually see it work (and be fun). **\[Emergent Thing\] + \[Function\] + \[Flavor\]**
* API calls to locally-installed model for now. 

#### GenAI: Example output

"Zone 12 yielded **2 kilo of beta** mineral. But a chemical spill at the extraction site has created an eco-disaster."

In the backend, genAI has added a _novel game mechanic_ onto the game platform for Planet AN645 Zone 12. It has a simple but novel and deterministic function the platform is ready to accept.

`{
    "name": "chemical-spill",
    "function": "chemicalSpillPAN645Z12()",
    "library": "src/platform/extenders/ecodisasters",
}`

**In the file**: The function is a pure mathematical expression that modifies zone state deterministically. For example: `chemicalSpillPAN645Z12(zoneState) => { ...zoneState, mineralYield: zoneState.mineralYield * 0.5, explorationCost: zoneState.explorationCost + 1, effects: [...zoneState.effects, "toxic"] }`. The platform validates the function signature, ensures it returns a valid zone state, and integrates it into the resolution cycle. This is the proof: genAI didn't just write flavor text—it extended the game's mathematical ruleset with a novel, playable mechanic that persists and interacts with all other systems. Every player action in Zone 12 now accounts for the spill. The spill can spread to adjacent zones through mathematical propagation. Other emergent mechanics can reference it. The universe expands through code, not content.

#### GenAI: The semantic physics engine

The AI can't generate arbitrary code. It generates transformations within a known shape. This is the vocabulary the AI speaks.

##### 1. Bounded state schema

```typescript
type ZoneState = {
  mineralYield: number
  explorationCost: number
  effects: Effect[]
  strength: number
  owner: PlayerId | null
  // ... bounded, known fields
}
```

The AI doesn't invent new fields. It manipulates existing ones through mathematical expressions. The "emergence" comes from novel combinations and conditions, not novel data structures.

##### 2. Constrained expression language

No arbitrary JavaScript. A DSL that is expressive enough to create interesting mechanics, constrained enough to be safe and deterministic, can be validated before execution, and can be serialized and stored.

```typescript
type MechanicExpression = {
  condition: Predicate        // when does this trigger?
  transformation: Transform   // what does it do to state?
  duration: Duration          // how long does it last?
  propagation?: Propagation   // does it spread? how?
}

type Predicate = 
  | { type: 'always' }
  | { type: 'onAction', action: ActionType }
  | { type: 'probability', chance: number }
  | { type: 'stateCheck', field: string, operator: '>' | '<' | '==', value: number }
  | { type: 'and', predicates: Predicate[] }
  | { type: 'or', predicates: Predicate[] }

type Transform =
  | { type: 'multiply', field: string, value: number }
  | { type: 'add', field: string, value: number }
  | { type: 'set', field: string, value: any }
  | { type: 'addEffect', effect: Effect }
  | { type: 'removeEffect', effect: Effect }
  | { type: 'compound', transforms: Transform[] }
```

The AI outputs JSON conforming to this schema. The engine interprets it. No `eval()`. No arbitrary code execution.

##### 3. Validation layer

Before any AI-generated mechanic enters the game:

```typescript
function validateMechanic(m: MechanicExpression): ValidationResult {
  // Does the condition reference valid fields?
  // Does the transformation produce valid state?
  // Is the math bounded? (no mineralYield * 1000000)
  // Does it conflict with core invariants?
  // Can it create infinite loops with existing mechanics?
}
```

The AI proposes; the validator disposes.

##### 4. Mechanic registry

Generated mechanics need to live somewhere:

```typescript
type MechanicRegistry = {
  global: Mechanic[]                      // applies everywhere
  planetary: Map<PlanetId, Mechanic[]>
  zonal: Map<ZoneId, Mechanic[]>
  temporal: Mechanic[]                    // expires after N ticks
}
```

During resolution, collect all applicable mechanics and compose them:

```typescript
function resolveZone(zone: ZoneState, action: Action): ZoneState {
  const mechanics = [
    ...registry.global,
    ...registry.planetary.get(zone.planetId),
    ...registry.zonal.get(zone.id)
  ].filter(m => evaluatePredicate(m.condition, zone, action))
  
  return mechanics.reduce(
    (state, m) => applyTransform(m.transformation, state),
    zone
  )
}
```

##### 5. AI prompt structure

The AI fills out a structured form, not arbitrary code:

```
CONTEXT:
- Zone 12 on Planet AN645
- Terrain: Volcanic Deposit
- Current effects: none
- Player just extracted 2 Beta minerals
- Adjacent zones: [13, 14, 15]

TASK:
Generate an emergent event that makes narrative sense and creates interesting gameplay.

OUTPUT FORMAT (JSON):
{
  "name": "human-readable name",
  "flavorText": "1-2 sentences describing what happened",
  "mechanic": {
    "condition": { ... },
    "transformation": { ... },
    "duration": { ... },
    "propagation": { ... }
  }
}

CONSTRAINTS:
- Multipliers must be between 0.1 and 2.0
- Additive modifiers must be between -3 and +3
- Duration must be between 1 and 10 ticks
- Propagation chance must be below 0.3
```

##### 6. The interaction problem

If the AI generates "chemical spill reduces mineral yield by 50%" and later generates "solar flare doubles all extraction," what happens?

| Strategy | Description |
| :------- | :---------- |
| Explicit ordering | Mechanics have priority. Higher priority applies last. |
| Categorical separation | Effects are typed (multiplicative, additive, override). Same-type effects combine predictably. |
| AI-mediated resolution | When mechanics conflict, ask the AI to generate a resolution. Recursive, risky, but narratively rich. |
| Constraint-based | Define invariants (mineralYield >= 0, explorationCost <= 10) and clamp results. |

Start with categorical separation + constraint-based. Predictable composition with hard bounds.

##### 7. Persistence model

Generated mechanics are game state. They need to be serializable (JSON), versioned, auditable, and reversible.

```typescript
type StoredMechanic = {
  id: string
  createdAt: Date
  createdBy: 'ai' | 'system' | 'player'  // provenance
  sourceEvent: string                     // what triggered generation
  mechanic: MechanicExpression
  active: boolean
}
```

#### GenAI: Prototype plan

| Day | Goal | Deliverable |
| :-- | :--- | :---------- |
| 1 | Schema definition | Define ZoneState, Predicate, Transform, MechanicExpression types. Keep them small. |
| 2 | Manual mechanics | Write 5 mechanics by hand: a trap, a resource bonus, a movement penalty, an effect that spreads, an effect that expires. Make sure the engine can interpret them. |
| 3 | AI generation | Prompt Gemma/local model to generate mechanics in the schema. Measure: how often valid? How often interesting? How often broken? |
| 4 | Validation layer | Build the validator. What invariants matter? What bounds are reasonable? How to reject garbage gracefully? |
| 5 | Integration | Wire it together. Player explores zone → AI generates event → Engine validates → Mechanic enters registry → Next action accounts for it. |

#### GenAI: Future expansion

Totally playable and fun emergent content generated by genAI within strict mathematical constraints.

### 16. Player archetypes

The game doesn't have classes. Instead, these are thematic examples of emergent playstyles that the system will support.

| Archetype | Bodies | Holdings | Network |
| :-------- | :----- | :------- | :------ |
| Rogue Mercenary | Heavy | Light | Medium |
| Emperor | Light | Heavy | Heavy |
| Rebel Cell | Medium | Light | Heavy |
| Lone Wolf Saboteur | Heavy | None | Light |
| Mobile Trader | Medium | Medium | Heavy |
| Bunker Hermit | Light | Heavy | None |
| Intelligence Broker | Heavy | Light | Heavy |
| Logistics Magnate | Light | Heavy | Heavy |

The minimal version as written in this GDD will support at least the Rogue, Emperor, and Trader fantasies. If players naturally fall into these patterns during playtest, the systems are working.

### 17. Victory and loss

Everything is meaningless.

#### Victory and loss: Minimal definition

* No formal victory condition. The game is ongoing.
* Dominance could be measured by holdings, but they're not apples-to-apples. Controlling the most zones does not project more power inherently than someone playing a heavy body build buried in a fortfied bunker on a single dark moon with devestating hacking capabilities and nutty radio range.
* Restarting: If for any reason you want a new life, you can wake up with nothing into a heavily-fortified (aka civilized) zone. You cede control over holdings or prior bodies, but those holdings and bodies persist (and with future expansion, would gain their own sentience if applicable).
* The cowboy can always start over. The empire can always fall.

#### Victory and loss: Future expansion

Discoverability and slicing/dicing public information for prestige.

### 18. Technical architecture

How the systems connect. Maintainability over cleverness.

#### Core principle

The game is a state machine with a pure functional core. All game logic takes a state and an action, returns a new state and events. The resolver is a fold over actions. The UI is a plugged-in projection to change later. The database is just persistence.

#### Layers

| Layer | Responsibility | Dependencies |
| :---- | :------------- | :----------- |
| Domain core | Entity definitions, action resolution, event generation | None (pure) |
| Persistence adapter | Serialize/deserialize state, store action queue | Domain core |
| Generation sybsystem | Zone tessellation, lore assembly | Domain core |
| Presentation layer | Render map, display menus, submit actions | Domain core |
| Orchestration | HTTP API, scheduler, glue | All layers |

#### Key property

You can test the entire game in memory with no infrastructure. You can swap the UI completely. You can replay any game state by replaying the action log.

### 19. Playtest plan

How we validate the design.

#### Setup

* 5–10 players
* 7 consecutive days
* Players can pick: do they want to start as someone with a lot to lose? Or a lovable underdog? (Need a procedural way to do this)
* Out-of-band communication encouraged (Discord server)

#### Success metrics

1. Did players think about the game when they weren't playing it?
2. Did players talk to each other outside the game?
3. Did anyone try to do something the systems didn't support?
4. Did the daily pacing feel like anticipation or homework?

#### What we learn

The answers tell me what to build next.

## Appendix A: Sample lore atoms

Sentence fragments for world-building. _Eventually need a fresher take on this. The game will have a distinct way of speaking._

### Terrain open

* _"The barren dust of \[Zone\] crunched beneath your boots."_
* _"Ice crystals formed on your visor as you entered \[Zone\]."_
* _"Toxic fog rolled across \[Zone\], obscuring the horizon."_
* _"Metal ore veins glinted in \[Zone\]'s perpetual twilight."_

### Outcome connectors

* _"Your scanner pinged. Deposits confirmed."_
* _"Half-buried in the sediment, something glinted."_
* _"Movement. Not friendly."_

### Flavor closers

* _"The Combine's satellites watched, as always."_
* _"Somewhere, someone was making a fortune off your labor."_
* _"Another day survived. Another day closer to something."_

## Appendix B: Core data structures

Reference definitions for implementation.

### GameState

`{ planets: Planet[], players: Player[], contracts: Contract[\], tradeOffers: TradeOffer[], eventLog: Event[] }`

### Planet

`{ id: string, name: string, zones: Zone[] }`

### Zone

`{ id: string, planetId: string, terrain: TerrainType, strength: 1-5, owner: PlayerId | null, minerals: { type: MineralType, amount: 0-3 } | null, adjacentZoneIds: string[], polygon: Point[] }`

### Player

`{ id: string, name: string, bodyLocation: { planetId: string, zoneId: string }, inventory: { minerals: { \[MineralType\]: number }, equipment: EquipmentType[] }, ownedZoneIds: string[] }`

### Action

`{ playerId: string, type: ActionType, payload: { ... } }`

### Event

` timestamp: Date, type: EventType, playerId: string, description: string, data: { ... }`
